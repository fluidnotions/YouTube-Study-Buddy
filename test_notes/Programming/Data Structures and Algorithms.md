# Data Structures and Algorithms

## Fundamental Data Structures

### Arrays and Lists
Sequential collections providing indexed access. Arrays offer O(1) lookup but fixed size, while dynamic lists can grow.

### Hash Tables
Key-value stores with O(1) average-case insertion and lookup. Hash functions map keys to array indices, with collision resolution strategies.

### Trees and Graphs
Hierarchical (trees) and networked (graphs) structures model relationships. Binary search trees enable efficient sorted data operations.

### Stacks and Queues
Stacks follow LIFO (Last In, First Out) principle, queues use FIFO (First In, First Out). Both are essential for many algorithms.

## Algorithm Paradigms

### Divide and Conquer
Break problems into smaller subproblems, solve recursively, and combine results. Examples: merge sort, quicksort, binary search.

### Dynamic Programming
Solve overlapping subproblems once and store results for reuse. Optimal for optimization problems with recursive structure.

### Greedy Algorithms
Make locally optimal choices at each step. Works when local optima lead to global optima, like in Dijkstra's shortest path.

### Graph Algorithms
Traversal (BFS, DFS), shortest paths (Dijkstra, Bellman-Ford), and minimum spanning trees (Kruskal, Prim) are fundamental.

## Complexity Analysis
Big O notation describes algorithm efficiency. Common complexities: O(1), O(log n), O(n), O(n log n), O(nÂ²), O(2^n).
